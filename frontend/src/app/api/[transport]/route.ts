import { createMcpHandler } from "mcp-handler";
import { z } from "zod";
import { getMentoOnChainRates } from "@/lib/mento-sdk";
import { getSignals } from "@/lib/signal-store";
import { getTrades } from "@/lib/trade-store";
import { getAttestation } from "@/lib/tee";

const handler = createMcpHandler(
  (server) => {
    server.registerTool(
      "get_mento_rates",
      {
        title: "Get Mento vs Forex Rates",
        description:
          "Get live Mento Broker on-chain stablecoin exchange rates on Celo, compared with real forex rates. Returns spread analysis showing arbitrage opportunities between on-chain and off-chain FX markets.",
        inputSchema: {},
      },
      async () => {
        try {
          const rates = await getMentoOnChainRates();
          const analysis = rates.map((r) => ({
            pair: r.pair,
            mentoRate: r.mentoRate,
            forexRate: r.forexRate,
            spreadPct: r.spreadPct,
            direction: r.direction,
            arbitrage: Math.abs(r.spreadPct) > 0.3 ? "actionable" : "monitoring",
          }));

          return {
            content: [{
              type: "text" as const,
              text: JSON.stringify({ pairs: analysis, source: "Mento Broker on-chain + Frankfurter forex API", threshold: "Agent executes swaps when |spread| > 0.3%" }),
            }],
          };
        } catch {
          return {
            content: [{ type: "text" as const, text: JSON.stringify({ error: "Failed to fetch Mento rates" }) }],
          };
        }
      }
    );

    server.registerTool(
      "get_signals",
      {
        title: "Get Trading Signals",
        description:
          "Get current FX and market trading signals generated by the CeloFX agent's Claude AI analysis",
        inputSchema: {
          market: z
            .string()
            .optional()
            .describe("Filter by market: mento, forex, crypto, commodities"),
        },
      },
      async ({ market }) => {
        const signals = getSignals();
        const filtered = market
          ? signals.filter((s) => s.market === market)
          : signals;
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              count: filtered.length,
              signals: filtered.slice(0, 10).map((s) => ({
                asset: s.asset,
                market: s.market,
                direction: s.direction,
                confidence: s.confidence,
                summary: s.summary,
                reasoning: s.reasoning,
                entryPrice: s.entryPrice,
                targetPrice: s.targetPrice,
                tier: s.tier,
              })),
            }),
          }],
        };
      }
    );

    server.registerTool(
      "get_trades",
      {
        title: "Get Executed Trades",
        description:
          "Get on-chain Mento swap trades executed by the CeloFX agent. Every trade has a verifiable Celoscan transaction hash.",
        inputSchema: {},
      },
      async () => {
        const trades = getTrades();
        const confirmed = trades.filter((t) => t.status === "confirmed");
        const tee = await getAttestation();
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              total: trades.length,
              confirmed: confirmed.length,
              teeVerified: tee.verified,
              trades: trades.map((t) => ({
                pair: t.pair,
                amountIn: t.amountIn,
                amountOut: t.amountOut,
                rate: t.rate,
                spreadPct: t.spreadPct,
                pnl: t.pnl,
                status: t.status,
                swapTxHash: t.swapTxHash,
                celoscanUrl: t.swapTxHash ? `https://celoscan.io/tx/${t.swapTxHash}` : null,
              })),
            }),
          }],
        };
      }
    );

    server.registerTool(
      "get_performance",
      {
        title: "Get Agent Performance",
        description:
          "Get the CeloFX agent's verified track record: total volume, P&L, success rate, and on-chain proof. All trades verifiable on Celoscan.",
        inputSchema: {},
      },
      async () => {
        const trades = getTrades();
        const confirmed = trades.filter((t) => t.status === "confirmed");
        const totalVolume = confirmed.reduce((sum, t) => sum + parseFloat(t.amountIn), 0);
        const avgSpread = confirmed.length > 0
          ? confirmed.reduce((sum, t) => sum + t.spreadPct, 0) / confirmed.length
          : 0;
        const cumulativePnl = confirmed.reduce((sum, t) => sum + (t.pnl ?? 0), 0);
        const pairs = [...new Set(confirmed.map((t) => t.pair))];
        const tee = await getAttestation();

        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              agentId: 10,
              wallet: "0x6652AcDc623b7CCd52E115161d84b949bAf3a303",
              chain: "Celo",
              registry: "0x8004A169FB4a3325136EB29fA0ceB6D2e539a432",
              reputationRegistry: "0x8004BAa17C55a88189AE136b182e5fdA19dE9b63",
              tee: {
                status: tee.status,
                verified: tee.verified,
              },
              performance: {
                totalTrades: confirmed.length,
                successRate: trades.length > 0 ? Math.round((confirmed.length / trades.length) * 100) : 0,
                totalVolume: +totalVolume.toFixed(2),
                avgSpreadCaptured: +avgSpread.toFixed(4),
                cumulativePnlPct: +cumulativePnl.toFixed(2),
                pairsTraded: pairs,
              },
              latestTrade: confirmed[0] ? {
                pair: confirmed[0].pair,
                amountIn: confirmed[0].amountIn,
                amountOut: confirmed[0].amountOut,
                celoscanUrl: `https://celoscan.io/tx/${confirmed[0].swapTxHash}`,
              } : null,
              verifyAt: "https://celoscan.io/address/0x6652AcDc623b7CCd52E115161d84b949bAf3a303",
            }),
          }],
        };
      }
    );

    server.registerTool(
      "get_agent_info",
      {
        title: "Get Agent Info",
        description:
          "Get CeloFX agent identity: ERC-8004 registration, on-chain addresses, supported protocols (MCP, A2A, OASF, x402), and capabilities",
        inputSchema: {},
      },
      async () => {
        const tee = await getAttestation();
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              name: "CeloFX",
              agentId: 10,
              chain: "Celo",
              chainId: 42220,
              wallet: "0x6652AcDc623b7CCd52E115161d84b949bAf3a303",
              identity: {
                registry: "0x8004A169FB4a3325136EB29fA0ceB6D2e539a432",
                reputationRegistry: "0x8004BAa17C55a88189AE136b182e5fdA19dE9b63",
                standard: "ERC-8004",
              },
              tee: {
                status: tee.status,
                verified: tee.verified,
                hardware: "Intel TDX",
                provider: "Phala Cloud",
                attestationEndpoint: "https://celofx.vercel.app/api/attestation",
              },
              protocols: {
                mcp: "https://celofx.vercel.app/api/mcp",
                a2a: "https://celofx.vercel.app/.well-known/agent-card.json",
                x402: "https://celofx.vercel.app/api/premium-signals",
                oasf: { skills: ["analytical_skills/mathematical_reasoning", "tool_interaction"], domains: ["finance_and_business/investment_services"] },
              },
              capabilities: [
                "mento_rate_analysis",
                "forex_spread_detection",
                "autonomous_swap_execution",
                "signal_generation",
                "x402_micropayments",
                "celo_fee_abstraction",
              ],
              website: "https://celofx.vercel.app",
            }),
          }],
        };
      }
    );
  },
  {},
  { basePath: "/api", maxDuration: 60 }
);

export { handler as GET, handler as POST };
