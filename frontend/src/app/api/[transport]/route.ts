import { createMcpHandler } from "mcp-handler";
import { z } from "zod";
import { getMentoOnChainRates } from "@/lib/mento-sdk";
import { getSignals } from "@/lib/signal-store";
import { getTrades } from "@/lib/trade-store";
import { getAttestation } from "@/lib/tee";
import { AGENT_POLICY, getDecisionLog } from "@/lib/agent-policy";

const handler = createMcpHandler(
  (server) => {
    server.registerTool(
      "get_mento_rates",
      {
        title: "Get Mento vs Forex Rates",
        description:
          "Get live Mento Broker on-chain stablecoin exchange rates on Celo, compared with real forex rates. Returns spread analysis showing arbitrage opportunities between on-chain and off-chain FX markets.",
        inputSchema: {},
      },
      async () => {
        try {
          const rates = await getMentoOnChainRates();
          const analysis = rates.map((r) => ({
            pair: r.pair,
            mentoRate: r.mentoRate,
            forexRate: r.forexRate,
            spreadPct: r.spreadPct,
            direction: r.direction,
            arbitrage: Math.abs(r.spreadPct) > 0.3 ? "actionable" : "monitoring",
          }));

          return {
            content: [{
              type: "text" as const,
              text: JSON.stringify({ pairs: analysis, source: "Mento Broker on-chain + Frankfurter forex API", threshold: "Agent executes swaps when |spread| > 0.3%" }),
            }],
          };
        } catch {
          return {
            content: [{ type: "text" as const, text: JSON.stringify({ error: "Failed to fetch Mento rates" }) }],
          };
        }
      }
    );

    server.registerTool(
      "get_signals",
      {
        title: "Get Trading Signals",
        description:
          "Get current FX and market trading signals generated by the CeloFX agent's Claude AI analysis",
        inputSchema: {
          market: z
            .string()
            .optional()
            .describe("Filter by market: mento, forex, crypto, commodities"),
        },
      },
      async ({ market }) => {
        const signals = getSignals();
        const filtered = market
          ? signals.filter((s) => s.market === market)
          : signals;
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              count: filtered.length,
              signals: filtered.slice(0, 10).map((s) => ({
                asset: s.asset,
                market: s.market,
                direction: s.direction,
                confidence: s.confidence,
                summary: s.summary,
                reasoning: s.reasoning,
                entryPrice: s.entryPrice,
                targetPrice: s.targetPrice,
                tier: s.tier,
              })),
            }),
          }],
        };
      }
    );

    server.registerTool(
      "get_trades",
      {
        title: "Get Executed Trades",
        description:
          "Get on-chain Mento swap trades executed by the CeloFX agent. Every trade has a verifiable Celoscan transaction hash.",
        inputSchema: {},
      },
      async () => {
        const trades = getTrades();
        const confirmed = trades.filter((t) => t.status === "confirmed");
        const tee = await getAttestation();
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              total: trades.length,
              confirmed: confirmed.length,
              teeVerified: tee.verified,
              trades: trades.map((t) => ({
                pair: t.pair,
                amountIn: t.amountIn,
                amountOut: t.amountOut,
                rate: t.rate,
                spreadPct: t.spreadPct,
                pnl: t.pnl,
                status: t.status,
                swapTxHash: t.swapTxHash,
                celoscanUrl: t.swapTxHash ? `https://celoscan.io/tx/${t.swapTxHash}` : null,
              })),
            }),
          }],
        };
      }
    );

    server.registerTool(
      "get_performance",
      {
        title: "Get Agent Performance",
        description:
          "Get the CeloFX agent's verified track record: total volume, P&L, success rate, and on-chain proof. All trades verifiable on Celoscan.",
        inputSchema: {},
      },
      async () => {
        const trades = getTrades();
        const confirmed = trades.filter((t) => t.status === "confirmed");
        const totalVolume = confirmed.reduce((sum, t) => sum + parseFloat(t.amountIn), 0);
        const avgSpread = confirmed.length > 0
          ? confirmed.reduce((sum, t) => sum + t.spreadPct, 0) / confirmed.length
          : 0;
        const cumulativePnl = confirmed.reduce((sum, t) => sum + (t.pnl ?? 0), 0);
        const pairs = [...new Set(confirmed.map((t) => t.pair))];
        const tee = await getAttestation();

        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              agentId: 10,
              wallet: "0x6652AcDc623b7CCd52E115161d84b949bAf3a303",
              chain: "Celo",
              registry: "0x8004A169FB4a3325136EB29fA0ceB6D2e539a432",
              reputationRegistry: "0x8004BAa17C55a88189AE136b182e5fdA19dE9b63",
              tee: {
                status: tee.status,
                verified: tee.verified,
              },
              performance: {
                totalTrades: confirmed.length,
                successRate: trades.length > 0 ? Math.round((confirmed.length / trades.length) * 100) : 0,
                totalVolume: +totalVolume.toFixed(2),
                avgSpreadCaptured: +avgSpread.toFixed(4),
                cumulativePnlPct: +cumulativePnl.toFixed(2),
                pairsTraded: pairs,
              },
              latestTrade: confirmed[0] ? {
                pair: confirmed[0].pair,
                amountIn: confirmed[0].amountIn,
                amountOut: confirmed[0].amountOut,
                celoscanUrl: `https://celoscan.io/tx/${confirmed[0].swapTxHash}`,
              } : null,
              verifyAt: "https://celoscan.io/address/0x6652AcDc623b7CCd52E115161d84b949bAf3a303",
            }),
          }],
        };
      }
    );

    server.registerTool(
      "get_agent_info",
      {
        title: "Get Agent Info",
        description:
          "Get CeloFX agent identity: ERC-8004 registration, on-chain addresses, supported protocols (MCP, A2A, OASF, x402), and capabilities",
        inputSchema: {},
      },
      async () => {
        const tee = await getAttestation();
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              name: "CeloFX",
              agentId: 10,
              chain: "Celo",
              chainId: 42220,
              wallet: "0x6652AcDc623b7CCd52E115161d84b949bAf3a303",
              identity: {
                registry: "0x8004A169FB4a3325136EB29fA0ceB6D2e539a432",
                reputationRegistry: "0x8004BAa17C55a88189AE136b182e5fdA19dE9b63",
                standard: "ERC-8004",
              },
              tee: {
                status: tee.status,
                verified: tee.verified,
                hardware: "Intel TDX",
                provider: "Phala Cloud",
                attestationEndpoint: "https://celofx.vercel.app/api/attestation",
              },
              protocols: {
                mcp: "https://celofx.vercel.app/api/mcp",
                a2a: "https://celofx.vercel.app/.well-known/agent-card.json",
                x402: "https://celofx.vercel.app/api/premium-signals",
                oasf: { skills: ["analytical_skills/mathematical_reasoning", "tool_interaction"], domains: ["finance_and_business/investment_services"] },
              },
              capabilities: [
                "mento_rate_analysis",
                "forex_spread_detection",
                "autonomous_swap_execution",
                "signal_generation",
                "x402_micropayments",
                "celo_fee_abstraction",
              ],
              website: "https://celofx.vercel.app",
            }),
          }],
        };
      }
    );
    server.registerTool(
      "get_cross_venue_rates",
      {
        title: "Get Cross-Venue Rates",
        description:
          "Compare rates across Mento Broker and Uniswap V3 on Celo. Returns per-pair Mento rate, Uniswap rate, forex rate, and venue spread for cross-DEX arbitrage detection.",
        inputSchema: {},
      },
      async () => {
        try {
          const { getCrossVenueRates } = await import("@/lib/uniswap-quotes");
          const rates = await getCrossVenueRates();
          return {
            content: [{
              type: "text" as const,
              text: JSON.stringify({
                pairs: rates,
                venues: ["Mento Broker", "Uniswap V3"],
                arbThreshold: "0.3% venue spread",
              }),
            }],
          };
        } catch {
          return {
            content: [{ type: "text" as const, text: JSON.stringify({ error: "Failed to fetch cross-venue rates" }) }],
          };
        }
      }
    );

    server.registerTool(
      "get_agent_policy",
      {
        title: "Get Agent Policy (Standing Intent)",
        description:
          "Get the agent's cryptographically signed Standing Intent policy: allowed tokens, protocols, spending limits, and decision framework. This defines what the agent can and cannot do.",
        inputSchema: {},
      },
      async () => {
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              policy: AGENT_POLICY,
              enforcement: "All limits are runtime-enforced, not advisory. Volume caps, spread thresholds, and circuit breaker are checked before every swap execution.",
            }),
          }],
        };
      }
    );

    server.registerTool(
      "get_decision_log",
      {
        title: "Get Decision Audit Log",
        description:
          "Get the agent's keccak256-hashed decision audit trail. Every swap execution is committed with a hash BEFORE the transaction is sent, enabling verifiable decision auditability.",
        inputSchema: {},
      },
      async () => {
        const decisions = getDecisionLog();
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              count: decisions.length,
              decisions: decisions.slice(-20).map(d => ({
                orderId: d.orderId,
                action: d.action,
                hash: d.hash,
                timestamp: new Date(d.timestamp).toISOString(),
                reasoning: d.reasoning.slice(0, 200),
              })),
              verifyEndpoint: "https://celofx.vercel.app/api/agent/decisions",
            }),
          }],
        };
      }
    );
  },
  {},
  { basePath: "/api", maxDuration: 60 }
);

// MCP tools list (shared between GET and POST handlers)
const MCP_TOOLS = [
  { name: "get_mento_rates", description: "Get live Mento Broker on-chain stablecoin exchange rates compared with real forex rates.", inputSchema: { type: "object", properties: {} } },
  { name: "get_cross_venue_rates", description: "Compare rates across Mento Broker and Uniswap V3 on Celo for cross-DEX arbitrage detection.", inputSchema: { type: "object", properties: {} } },
  { name: "get_signals", description: "Get current FX and market trading signals generated by Claude AI analysis.", inputSchema: { type: "object", properties: { market: { type: "string", description: "Filter by market: mento, forex, crypto, commodities" } } } },
  { name: "get_trades", description: "Get on-chain Mento swap trades with verifiable Celoscan transaction hashes.", inputSchema: { type: "object", properties: {} } },
  { name: "get_performance", description: "Get agent verified track record: total volume, P&L, success rate.", inputSchema: { type: "object", properties: {} } },
  { name: "get_agent_info", description: "Get agent identity: ERC-8004 registration, protocols, capabilities.", inputSchema: { type: "object", properties: {} } },
  { name: "get_agent_policy", description: "Get agent Standing Intent policy: allowed tokens, protocols, spending limits, decision framework.", inputSchema: { type: "object", properties: {} } },
  { name: "get_decision_log", description: "Get keccak256-hashed decision audit trail for verifiable decision auditability.", inputSchema: { type: "object", properties: {} } },
];

// Override GET to return MCP server capabilities (8004scan probes with GET)
export async function GET(req: Request) {
  const url = new URL(req.url);
  if (url.pathname === "/api/mcp") {
    return Response.json({
      jsonrpc: "2.0",
      result: {
        protocolVersion: "2025-06-18",
        serverInfo: { name: "CeloFX MCP Server", version: "1.0.0" },
        capabilities: { tools: { listChanged: false } },
        tools: MCP_TOOLS,
      },
      id: null,
    });
  }
  return handler(req);
}

// Wrap POST â€” handle initialize/tools/list directly for probes (8004scan sends
// plain POST without Accept: text/event-stream which mcp-handler rejects).
// Real MCP clients with proper headers go through the library.
export async function POST(req: Request) {
  const accept = req.headers.get("accept") || "";
  if (!accept.includes("text/event-stream")) {
    try {
      const body = await req.json();
      const { jsonrpc, id, method } = body;
      if (jsonrpc !== "2.0") {
        return Response.json({ jsonrpc: "2.0", id, error: { code: -32600, message: "Invalid JSON-RPC" } });
      }
      switch (method) {
        case "initialize":
          return Response.json({
            jsonrpc: "2.0", id,
            result: {
              protocolVersion: "2025-06-18",
              serverInfo: { name: "CeloFX MCP Server", version: "1.0.0" },
              capabilities: { tools: { listChanged: false } },
            },
          });
        case "tools/list":
          return Response.json({ jsonrpc: "2.0", id, result: { tools: MCP_TOOLS } });
        case "notifications/initialized":
          return Response.json({ jsonrpc: "2.0", id, result: {} });
        default:
          return Response.json({ jsonrpc: "2.0", id, error: { code: -32601, message: `Use proper MCP client for tool calls. Method: ${method}` } });
      }
    } catch {
      return Response.json({ jsonrpc: "2.0", id: null, error: { code: -32700, message: "Parse error" } });
    }
  }
  return handler(req);
}
